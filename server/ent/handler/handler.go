// Code generated by entc, DO NOT EDIT.

package handler

import (
	"encoding/json"
	"net/http"
	"strconv"
	"time"

	"github.com/go-chi/chi"
	"github.com/go-playground/validator/v10"
	"github.com/liip/sheriff"
	"github.com/masseelch/render"
	"github.com/sirupsen/logrus"

	"skeleton/ent"
	"skeleton/ent/account"
	"skeleton/ent/tag"
	"skeleton/ent/transaction"
	"skeleton/ent/user"

	server "skeleton"

	server "skeleton"
)

// Shared handler.
type handler struct {
	*chi.Mux

	client    *ent.Client
	validator *validator.Validate
	logger    *logrus.Logger
}

// The AccountHandler.
type AccountHandler struct {
	*handler
}

// Create a new AccountHandler
func NewAccountHandler(c *ent.Client, v *validator.Validate, log *logrus.Logger) *AccountHandler {
	h := &AccountHandler{
		&handler{
			Mux:       chi.NewRouter(),
			client:    c,
			validator: v,
			logger:    log,
		},
	}

	h.Post("/", h.Create)
	h.Get("/{id:\\d+}", h.Read)
	h.Get("/{id:\\d+}", h.Update)

	h.Get("/", h.List)

	h.Get("/{id:\\d+}/users", h.Users)
	h.Get("/{id:\\d+}/transactions", h.Transactions)

	return h
}

// struct to bind the post body to.
type accountCreateRequest struct {
	Title        string `json:"title,omitempty" `
	Users        []int  `json:"users,omitempty" `
	Transactions []int  `json:"transactions,omitempty" `
}

// This function creates a new Account model and stores it in the database.
func (h AccountHandler) Create(w http.ResponseWriter, r *http.Request) {
	// Get the post data.
	d := accountCreateRequest{} // todo - allow form-url-encdoded/xml/protobuf data.
	if err := json.NewDecoder(r.Body).Decode(&d); err != nil {
		h.logger.WithError(err).Error("error decoding json")
		render.BadRequest(w, r, "invalid json string")
		return
	}

	// Validate the data.
	if err := h.validator.Struct(d); err != nil {
		if err, ok := err.(*validator.InvalidValidationError); ok {
			h.logger.WithError(err).Error("error validating request data")
			render.InternalServerError(w, r, nil)
			return
		}

		h.logger.WithError(err).Info("validation failed")
		render.BadRequest(w, r, err)
		return
	}

	// Save the data.
	b := h.client.Account.Create().
		SetTitle(d.Title).
		AddUserIDs(d.Users...).
		AddTransactionIDs(d.Transactions...)

	// Store in database.
	e, err := b.Save(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error saving Account")
		render.InternalServerError(w, r, nil)
		return
	}

	// Serialize the data.
	j, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"account:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("Account.id", e.ID).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("account", e.ID).Info("account rendered")
	render.OK(w, r, j)
}

// This function fetches the Account model identified by a give url-parameter from
// database and returns it to the client.
func (h AccountHandler) Read(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}

	q := h.client.Account.Query().Where(account.ID(id))

	e, err := q.Only(r.Context())

	if err != nil {
		switch err.(type) {
		case *ent.NotFoundError:
			h.logger.WithError(err).WithField("Account.id", id).Debug("job not found")
			render.NotFound(w, r, err)
			return
		case *ent.NotSingularError:
			h.logger.WithError(err).WithField("Account.id", id).Error("duplicate entry for id")
			render.InternalServerError(w, r, nil)
			return
		default:
			h.logger.WithError(err).WithField("Account.id", id).Error("error fetching node from db")
			render.InternalServerError(w, r, nil)
			return
		}
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"account:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("Account.id", id).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("account", e.ID).Info("account rendered")
	render.OK(w, r, d)
}

// struct to bind the post body to.
type accountUpdateRequest struct {
	Title        string `json:"title,omitempty" `
	Users        []int  `json:"users,omitempty" `
	Transactions []int  `json:"transactions,omitempty" `
}

// This function updates a given Account model and saves the changes in the database.
func (h AccountHandler) Update(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}

	// Get the post data.
	d := accountUpdateRequest{} // todo - allow form-url-encoded/xml/protobuf data.
	if err := json.NewDecoder(r.Body).Decode(&d); err != nil {
		h.logger.WithError(err).Error("error decoding json")
		render.BadRequest(w, r, "invalid json string")
		return
	}

	// Validate the data.
	if err := h.validator.Struct(d); err != nil {
		if err, ok := err.(*validator.InvalidValidationError); ok {
			h.logger.WithError(err).Error("error validating request data")
			render.InternalServerError(w, r, nil)
			return
		}

		h.logger.WithError(err).Info("validation failed")
		render.BadRequest(w, r, err)
		return
	}

	// Save the data.
	b := h.client.Account.UpdateOneID(id).
		SetTitle(d.Title).
		AddUserIDs(d.Users...).
		AddTransactionIDs(d.Transactions...)

	// Save in database.
	e, err := b.Save(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error saving Account")
		render.InternalServerError(w, r, nil)
		return
	}

	// Serialize the data.
	j, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"account:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("Account.id", e.ID).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("account", e.ID).Info("account rendered")
	render.OK(w, r, j)
}

// This function queries for Account models. Can be filtered by query parameters.
func (h AccountHandler) List(w http.ResponseWriter, r *http.Request) {
	q := h.client.Account.Query()

	// Pagination
	page, itemsPerPage, err := h.paginationInfo(w, r)
	if err != nil {
		return
	}

	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	// Use the query parameters to filter the query. todo - nested filter?
	if f := r.URL.Query().Get("title"); f != "" {
		q.Where(account.Title(f))
	}

	es, err := q.All(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error querying database") // todo - better error
		render.InternalServerError(w, r, nil)
		return
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"account:list"}}, es)
	if err != nil {
		h.logger.WithError(err).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("amount", len(es)).Info("account rendered")
	render.OK(w, r, d)
}

func (h AccountHandler) Users(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}
	q := h.client.Account.Query().Where(account.ID(id)).QueryUsers()

	// Pagination
	page, itemsPerPage, err := h.paginationInfo(w, r)
	if err != nil {
		return
	}

	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	// Use the query parameters to filter the query. todo - nested filter?
	if f := r.URL.Query().Get("email"); f != "" {
		q.Where(user.Email(f))
	}

	if f := r.URL.Query().Get("password"); f != "" {
		q.Where(user.Password(f))
	}

	if f := r.URL.Query().Get("enabled"); f != "" {
		var b bool
		if f == "true" {
			b = true
		} else if f == "false" {
			b = false
		} else {
			h.logger.WithError(err).WithField("enabled", f).Debug("could not parse query parameter")
			render.BadRequest(w, r, "'enabled' must be 'true' or 'false'")
			return
		}
		q.Where(user.Enabled(b))
	}

	if f := r.URL.Query().Get("firstName"); f != "" {
		q.Where(user.FirstName(f))
	}

	if f := r.URL.Query().Get("lastName"); f != "" {
		q.Where(user.LastName(f))
	}

	es, err := q.All(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error querying database") // todo - better error
		render.InternalServerError(w, r, nil)
		return
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"user:list"}}, es)
	if err != nil {
		h.logger.WithError(err).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("amount", len(es)).Info("user rendered")
	render.OK(w, r, d)

}

func (h AccountHandler) Transactions(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}
	q := h.client.Account.Query().Where(account.ID(id)).QueryTransactions()

	if r.URL.Query().Get("order") == "" {
		q.Order(ent.Desc("date"))
	}

	// Eager load edges.
	q.WithUser().WithTags(func(q *ent.TagQuery) {
		q.Order(ent.Asc("title"))
	})

	// Pagination
	page, itemsPerPage, err := h.paginationInfo(w, r)
	if err != nil {
		return
	}

	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	// Use the query parameters to filter the query. todo - nested filter?
	if f := r.URL.Query().Get("date"); f != "" {
		// todo
	}

	if f := r.URL.Query().Get("amount"); f != "" {
		i, err := strconv.Atoi(f)
		if err != nil {
			h.logger.WithError(err).WithField("amount", f).Debug("could not parse query parameter")
			render.BadRequest(w, r, "'amount' must be an integer")
			return
		}
		q.Where(transaction.Amount(i))
	}

	if f := r.URL.Query().Get("title"); f != "" {
		q.Where(transaction.Title(f))
	}

	es, err := q.All(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error querying database") // todo - better error
		render.InternalServerError(w, r, nil)
		return
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"transaction:list", "user:list", "tag:list"}}, es)
	if err != nil {
		h.logger.WithError(err).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("amount", len(es)).Info("transaction rendered")
	render.OK(w, r, d)

}

// The TagHandler.
type TagHandler struct {
	*handler
}

// Create a new TagHandler
func NewTagHandler(c *ent.Client, v *validator.Validate, log *logrus.Logger) *TagHandler {
	h := &TagHandler{
		&handler{
			Mux:       chi.NewRouter(),
			client:    c,
			validator: v,
			logger:    log,
		},
	}

	h.Post("/", h.Create)
	h.Get("/{id:\\d+}", h.Read)
	h.Get("/{id:\\d+}", h.Update)

	h.Get("/", h.List)

	h.Get("/{id:\\d+}/transactions", h.Transactions)

	return h
}

// struct to bind the post body to.
type tagCreateRequest struct {
	Title        string       `json:"title,omitempty" `
	Color        server.Color `json:"color,omitempty" `
	Transactions []int        `json:"transactions,omitempty" `
}

// This function creates a new Tag model and stores it in the database.
func (h TagHandler) Create(w http.ResponseWriter, r *http.Request) {
	// Get the post data.
	d := tagCreateRequest{} // todo - allow form-url-encdoded/xml/protobuf data.
	if err := json.NewDecoder(r.Body).Decode(&d); err != nil {
		h.logger.WithError(err).Error("error decoding json")
		render.BadRequest(w, r, "invalid json string")
		return
	}

	// Validate the data.
	if err := h.validator.Struct(d); err != nil {
		if err, ok := err.(*validator.InvalidValidationError); ok {
			h.logger.WithError(err).Error("error validating request data")
			render.InternalServerError(w, r, nil)
			return
		}

		h.logger.WithError(err).Info("validation failed")
		render.BadRequest(w, r, err)
		return
	}

	// Save the data.
	b := h.client.Tag.Create().
		SetTitle(d.Title).
		SetColor(d.Color).
		AddTransactionIDs(d.Transactions...)

	// Store in database.
	e, err := b.Save(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error saving Tag")
		render.InternalServerError(w, r, nil)
		return
	}

	// Serialize the data.
	j, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"tag:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("Tag.id", e.ID).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("tag", e.ID).Info("tag rendered")
	render.OK(w, r, j)
}

// This function fetches the Tag model identified by a give url-parameter from
// database and returns it to the client.
func (h TagHandler) Read(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}

	q := h.client.Tag.Query().Where(tag.ID(id))

	e, err := q.Only(r.Context())

	if err != nil {
		switch err.(type) {
		case *ent.NotFoundError:
			h.logger.WithError(err).WithField("Tag.id", id).Debug("job not found")
			render.NotFound(w, r, err)
			return
		case *ent.NotSingularError:
			h.logger.WithError(err).WithField("Tag.id", id).Error("duplicate entry for id")
			render.InternalServerError(w, r, nil)
			return
		default:
			h.logger.WithError(err).WithField("Tag.id", id).Error("error fetching node from db")
			render.InternalServerError(w, r, nil)
			return
		}
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"tag:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("Tag.id", id).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("tag", e.ID).Info("tag rendered")
	render.OK(w, r, d)
}

// struct to bind the post body to.
type tagUpdateRequest struct {
	Title        string       `json:"title,omitempty" `
	Color        server.Color `json:"color,omitempty" `
	Transactions []int        `json:"transactions,omitempty" `
}

// This function updates a given Tag model and saves the changes in the database.
func (h TagHandler) Update(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}

	// Get the post data.
	d := tagUpdateRequest{} // todo - allow form-url-encoded/xml/protobuf data.
	if err := json.NewDecoder(r.Body).Decode(&d); err != nil {
		h.logger.WithError(err).Error("error decoding json")
		render.BadRequest(w, r, "invalid json string")
		return
	}

	// Validate the data.
	if err := h.validator.Struct(d); err != nil {
		if err, ok := err.(*validator.InvalidValidationError); ok {
			h.logger.WithError(err).Error("error validating request data")
			render.InternalServerError(w, r, nil)
			return
		}

		h.logger.WithError(err).Info("validation failed")
		render.BadRequest(w, r, err)
		return
	}

	// Save the data.
	b := h.client.Tag.UpdateOneID(id).
		SetTitle(d.Title).
		SetColor(d.Color).
		AddTransactionIDs(d.Transactions...)

	// Save in database.
	e, err := b.Save(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error saving Tag")
		render.InternalServerError(w, r, nil)
		return
	}

	// Serialize the data.
	j, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"tag:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("Tag.id", e.ID).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("tag", e.ID).Info("tag rendered")
	render.OK(w, r, j)
}

// This function queries for Tag models. Can be filtered by query parameters.
func (h TagHandler) List(w http.ResponseWriter, r *http.Request) {
	q := h.client.Tag.Query()

	if r.URL.Query().Get("order") == "" {
		q.Order(ent.Asc("title"))
	}

	// Pagination
	page, itemsPerPage, err := h.paginationInfo(w, r)
	if err != nil {
		return
	}

	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	// Use the query parameters to filter the query. todo - nested filter?
	if f := r.URL.Query().Get("title"); f != "" {
		q.Where(tag.Title(f))
	}

	if f := r.URL.Query().Get("color"); f != "" {
	}

	es, err := q.All(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error querying database") // todo - better error
		render.InternalServerError(w, r, nil)
		return
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"tag:list"}}, es)
	if err != nil {
		h.logger.WithError(err).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("amount", len(es)).Info("tag rendered")
	render.OK(w, r, d)
}

func (h TagHandler) Transactions(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}
	q := h.client.Tag.Query().Where(tag.ID(id)).QueryTransactions()

	// Eager load edges.
	q.WithUser().WithAccount()

	// Pagination
	page, itemsPerPage, err := h.paginationInfo(w, r)
	if err != nil {
		return
	}

	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	// Use the query parameters to filter the query. todo - nested filter?
	if f := r.URL.Query().Get("date"); f != "" {
		// todo
	}

	if f := r.URL.Query().Get("amount"); f != "" {
		i, err := strconv.Atoi(f)
		if err != nil {
			h.logger.WithError(err).WithField("amount", f).Debug("could not parse query parameter")
			render.BadRequest(w, r, "'amount' must be an integer")
			return
		}
		q.Where(transaction.Amount(i))
	}

	if f := r.URL.Query().Get("title"); f != "" {
		q.Where(transaction.Title(f))
	}

	es, err := q.All(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error querying database") // todo - better error
		render.InternalServerError(w, r, nil)
		return
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"transaction:list", "user:list", "tag:list"}}, es)
	if err != nil {
		h.logger.WithError(err).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("amount", len(es)).Info("transaction rendered")
	render.OK(w, r, d)

}

// The TransactionHandler.
type TransactionHandler struct {
	*handler
}

// Create a new TransactionHandler
func NewTransactionHandler(c *ent.Client, v *validator.Validate, log *logrus.Logger) *TransactionHandler {
	h := &TransactionHandler{
		&handler{
			Mux:       chi.NewRouter(),
			client:    c,
			validator: v,
			logger:    log,
		},
	}

	h.Post("/", h.Create)
	h.Get("/{id:\\d+}", h.Read)
	h.Get("/{id:\\d+}", h.Update)

	h.Get("/", h.List)

	h.Get("/{id:\\d+}/user", h.User)
	h.Get("/{id:\\d+}/account", h.Account)
	h.Get("/{id:\\d+}/tags", h.Tags)

	return h
}

// struct to bind the post body to.
type transactionCreateRequest struct {
	Date    time.Time    `json:"date,omitempty" `
	Amount  server.Money `json:"amount,omitempty" `
	Title   string       `json:"title,omitempty" `
	User    int          `json:"user,omitempty" `
	Account int          `json:"account,omitempty" `
	Tags    []int        `json:"tags,omitempty" `
}

// This function creates a new Transaction model and stores it in the database.
func (h TransactionHandler) Create(w http.ResponseWriter, r *http.Request) {
	// Get the post data.
	d := transactionCreateRequest{} // todo - allow form-url-encdoded/xml/protobuf data.
	if err := json.NewDecoder(r.Body).Decode(&d); err != nil {
		h.logger.WithError(err).Error("error decoding json")
		render.BadRequest(w, r, "invalid json string")
		return
	}

	// Validate the data.
	if err := h.validator.Struct(d); err != nil {
		if err, ok := err.(*validator.InvalidValidationError); ok {
			h.logger.WithError(err).Error("error validating request data")
			render.InternalServerError(w, r, nil)
			return
		}

		h.logger.WithError(err).Info("validation failed")
		render.BadRequest(w, r, err)
		return
	}

	// Save the data.
	b := h.client.Transaction.Create().
		SetDate(d.Date).
		SetAmount(d.Amount).
		SetTitle(d.Title).
		SetUserID(d.User).
		SetAccountID(d.Account).
		AddTagIDs(d.Tags...)

	// Store in database.
	e, err := b.Save(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error saving Transaction")
		render.InternalServerError(w, r, nil)
		return
	}

	// Serialize the data.
	j, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"transaction:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("Transaction.id", e.ID).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("transaction", e.ID).Info("transaction rendered")
	render.OK(w, r, j)
}

// This function fetches the Transaction model identified by a give url-parameter from
// database and returns it to the client.
func (h TransactionHandler) Read(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}

	q := h.client.Transaction.Query().Where(transaction.ID(id))

	e, err := q.Only(r.Context())

	if err != nil {
		switch err.(type) {
		case *ent.NotFoundError:
			h.logger.WithError(err).WithField("Transaction.id", id).Debug("job not found")
			render.NotFound(w, r, err)
			return
		case *ent.NotSingularError:
			h.logger.WithError(err).WithField("Transaction.id", id).Error("duplicate entry for id")
			render.InternalServerError(w, r, nil)
			return
		default:
			h.logger.WithError(err).WithField("Transaction.id", id).Error("error fetching node from db")
			render.InternalServerError(w, r, nil)
			return
		}
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"transaction:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("Transaction.id", id).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("transaction", e.ID).Info("transaction rendered")
	render.OK(w, r, d)
}

// struct to bind the post body to.
type transactionUpdateRequest struct {
	Date    time.Time    `json:"date,omitempty" `
	Amount  server.Money `json:"amount,omitempty" `
	Title   string       `json:"title,omitempty" `
	User    int          `json:"user,omitempty" `
	Account int          `json:"account,omitempty" `
	Tags    []int        `json:"tags,omitempty" `
}

// This function updates a given Transaction model and saves the changes in the database.
func (h TransactionHandler) Update(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}

	// Get the post data.
	d := transactionUpdateRequest{} // todo - allow form-url-encoded/xml/protobuf data.
	if err := json.NewDecoder(r.Body).Decode(&d); err != nil {
		h.logger.WithError(err).Error("error decoding json")
		render.BadRequest(w, r, "invalid json string")
		return
	}

	// Validate the data.
	if err := h.validator.Struct(d); err != nil {
		if err, ok := err.(*validator.InvalidValidationError); ok {
			h.logger.WithError(err).Error("error validating request data")
			render.InternalServerError(w, r, nil)
			return
		}

		h.logger.WithError(err).Info("validation failed")
		render.BadRequest(w, r, err)
		return
	}

	// Save the data.
	b := h.client.Transaction.UpdateOneID(id).
		SetDate(d.Date).
		SetAmount(d.Amount).
		SetTitle(d.Title).
		SetUserID(d.User).
		SetAccountID(d.Account).
		AddTagIDs(d.Tags...)

	// Save in database.
	e, err := b.Save(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error saving Transaction")
		render.InternalServerError(w, r, nil)
		return
	}

	// Serialize the data.
	j, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"transaction:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("Transaction.id", e.ID).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("transaction", e.ID).Info("transaction rendered")
	render.OK(w, r, j)
}

// This function queries for Transaction models. Can be filtered by query parameters.
func (h TransactionHandler) List(w http.ResponseWriter, r *http.Request) {
	q := h.client.Transaction.Query()

	// Eager load edges.
	q.WithUser().WithAccount().WithTags()

	// Pagination
	page, itemsPerPage, err := h.paginationInfo(w, r)
	if err != nil {
		return
	}

	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	// Use the query parameters to filter the query. todo - nested filter?
	if f := r.URL.Query().Get("date"); f != "" {
		// todo
	}

	if f := r.URL.Query().Get("amount"); f != "" {
		i, err := strconv.Atoi(f)
		if err != nil {
			h.logger.WithError(err).WithField("amount", f).Debug("could not parse query parameter")
			render.BadRequest(w, r, "'amount' must be an integer")
			return
		}
		q.Where(transaction.Amount(i))
	}

	if f := r.URL.Query().Get("title"); f != "" {
		q.Where(transaction.Title(f))
	}

	es, err := q.All(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error querying database") // todo - better error
		render.InternalServerError(w, r, nil)
		return
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"transaction:list"}}, es)
	if err != nil {
		h.logger.WithError(err).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("amount", len(es)).Info("transaction rendered")
	render.OK(w, r, d)
}

func (h TransactionHandler) User(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}
	q := h.client.Transaction.Query().Where(transaction.ID(id)).QueryUser()

	e, err := q.Only(r.Context())

	if err != nil {
		switch err.(type) {
		case *ent.NotFoundError:
			h.logger.WithError(err).WithField("User.id", id).Debug("job not found")
			render.NotFound(w, r, err)
			return
		case *ent.NotSingularError:
			h.logger.WithError(err).WithField("User.id", id).Error("duplicate entry for id")
			render.InternalServerError(w, r, nil)
			return
		default:
			h.logger.WithError(err).WithField("User.id", id).Error("error fetching node from db")
			render.InternalServerError(w, r, nil)
			return
		}
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"user:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("User.id", id).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("user", e.ID).Info("user rendered")
	render.OK(w, r, d)

}

func (h TransactionHandler) Account(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}
	q := h.client.Transaction.Query().Where(transaction.ID(id)).QueryAccount()

	e, err := q.Only(r.Context())

	if err != nil {
		switch err.(type) {
		case *ent.NotFoundError:
			h.logger.WithError(err).WithField("Account.id", id).Debug("job not found")
			render.NotFound(w, r, err)
			return
		case *ent.NotSingularError:
			h.logger.WithError(err).WithField("Account.id", id).Error("duplicate entry for id")
			render.InternalServerError(w, r, nil)
			return
		default:
			h.logger.WithError(err).WithField("Account.id", id).Error("error fetching node from db")
			render.InternalServerError(w, r, nil)
			return
		}
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"account:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("Account.id", id).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("account", e.ID).Info("account rendered")
	render.OK(w, r, d)

}

func (h TransactionHandler) Tags(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}
	q := h.client.Transaction.Query().Where(transaction.ID(id)).QueryTags()

	if r.URL.Query().Get("order") == "" {
		q.Order(ent.Asc("title"))
	}

	// Pagination
	page, itemsPerPage, err := h.paginationInfo(w, r)
	if err != nil {
		return
	}

	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	// Use the query parameters to filter the query. todo - nested filter?
	if f := r.URL.Query().Get("title"); f != "" {
		q.Where(tag.Title(f))
	}

	if f := r.URL.Query().Get("color"); f != "" {
	}

	es, err := q.All(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error querying database") // todo - better error
		render.InternalServerError(w, r, nil)
		return
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"tag:list"}}, es)
	if err != nil {
		h.logger.WithError(err).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("amount", len(es)).Info("tag rendered")
	render.OK(w, r, d)

}

// The UserHandler.
type UserHandler struct {
	*handler
}

// Create a new UserHandler
func NewUserHandler(c *ent.Client, v *validator.Validate, log *logrus.Logger) *UserHandler {
	h := &UserHandler{
		&handler{
			Mux:       chi.NewRouter(),
			client:    c,
			validator: v,
			logger:    log,
		},
	}

	h.Post("/", h.Create)
	h.Get("/{id:\\d+}", h.Read)
	h.Get("/{id:\\d+}", h.Update)

	h.Get("/", h.List)

	h.Get("/{id:\\d+}/sessions", h.Sessions)
	h.Get("/{id:\\d+}/accounts", h.Accounts)
	h.Get("/{id:\\d+}/transactions", h.Transactions)

	return h
}

// struct to bind the post body to.
type userCreateRequest struct {
	Email     string `json:"email,omitempty" `
	Password  string `json:"password,omitempty" `
	Enabled   bool   `json:"enabled,omitempty" `
	FirstName string `json:"firstName,omitempty" `
	LastName  string `json:"lastName,omitempty" `
}

// This function creates a new User model and stores it in the database.
func (h UserHandler) Create(w http.ResponseWriter, r *http.Request) {
	// Get the post data.
	d := userCreateRequest{} // todo - allow form-url-encdoded/xml/protobuf data.
	if err := json.NewDecoder(r.Body).Decode(&d); err != nil {
		h.logger.WithError(err).Error("error decoding json")
		render.BadRequest(w, r, "invalid json string")
		return
	}

	// Validate the data.
	if err := h.validator.Struct(d); err != nil {
		if err, ok := err.(*validator.InvalidValidationError); ok {
			h.logger.WithError(err).Error("error validating request data")
			render.InternalServerError(w, r, nil)
			return
		}

		h.logger.WithError(err).Info("validation failed")
		render.BadRequest(w, r, err)
		return
	}

	// Save the data.
	b := h.client.User.Create().
		SetEmail(d.Email).
		SetPassword(d.Password).
		SetEnabled(d.Enabled).
		SetFirstName(d.FirstName).
		SetLastName(d.LastName)

	// Store in database.
	e, err := b.Save(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error saving User")
		render.InternalServerError(w, r, nil)
		return
	}

	// Serialize the data.
	j, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"user:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("User.id", e.ID).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("user", e.ID).Info("user rendered")
	render.OK(w, r, j)
}

// This function fetches the User model identified by a give url-parameter from
// database and returns it to the client.
func (h UserHandler) Read(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}

	q := h.client.User.Query().Where(user.ID(id))

	e, err := q.Only(r.Context())

	if err != nil {
		switch err.(type) {
		case *ent.NotFoundError:
			h.logger.WithError(err).WithField("User.id", id).Debug("job not found")
			render.NotFound(w, r, err)
			return
		case *ent.NotSingularError:
			h.logger.WithError(err).WithField("User.id", id).Error("duplicate entry for id")
			render.InternalServerError(w, r, nil)
			return
		default:
			h.logger.WithError(err).WithField("User.id", id).Error("error fetching node from db")
			render.InternalServerError(w, r, nil)
			return
		}
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"user:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("User.id", id).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("user", e.ID).Info("user rendered")
	render.OK(w, r, d)
}

// struct to bind the post body to.
type userUpdateRequest struct {
	Email     string `json:"email,omitempty" `
	Password  string `json:"password,omitempty" `
	Enabled   bool   `json:"enabled,omitempty" `
	FirstName string `json:"firstName,omitempty" `
	LastName  string `json:"lastName,omitempty" `
}

// This function updates a given User model and saves the changes in the database.
func (h UserHandler) Update(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}

	// Get the post data.
	d := userUpdateRequest{} // todo - allow form-url-encoded/xml/protobuf data.
	if err := json.NewDecoder(r.Body).Decode(&d); err != nil {
		h.logger.WithError(err).Error("error decoding json")
		render.BadRequest(w, r, "invalid json string")
		return
	}

	// Validate the data.
	if err := h.validator.Struct(d); err != nil {
		if err, ok := err.(*validator.InvalidValidationError); ok {
			h.logger.WithError(err).Error("error validating request data")
			render.InternalServerError(w, r, nil)
			return
		}

		h.logger.WithError(err).Info("validation failed")
		render.BadRequest(w, r, err)
		return
	}

	// Save the data.
	b := h.client.User.UpdateOneID(id).
		SetEmail(d.Email).
		SetPassword(d.Password).
		SetEnabled(d.Enabled).
		SetFirstName(d.FirstName).
		SetLastName(d.LastName)

	// Save in database.
	e, err := b.Save(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error saving User")
		render.InternalServerError(w, r, nil)
		return
	}

	// Serialize the data.
	j, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"user:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("User.id", e.ID).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("user", e.ID).Info("user rendered")
	render.OK(w, r, j)
}

// This function queries for User models. Can be filtered by query parameters.
func (h UserHandler) List(w http.ResponseWriter, r *http.Request) {
	q := h.client.User.Query()

	// Pagination
	page, itemsPerPage, err := h.paginationInfo(w, r)
	if err != nil {
		return
	}

	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	// Use the query parameters to filter the query. todo - nested filter?
	if f := r.URL.Query().Get("email"); f != "" {
		q.Where(user.Email(f))
	}

	if f := r.URL.Query().Get("password"); f != "" {
		q.Where(user.Password(f))
	}

	if f := r.URL.Query().Get("enabled"); f != "" {
		var b bool
		if f == "true" {
			b = true
		} else if f == "false" {
			b = false
		} else {
			h.logger.WithError(err).WithField("enabled", f).Debug("could not parse query parameter")
			render.BadRequest(w, r, "'enabled' must be 'true' or 'false'")
			return
		}
		q.Where(user.Enabled(b))
	}

	if f := r.URL.Query().Get("firstName"); f != "" {
		q.Where(user.FirstName(f))
	}

	if f := r.URL.Query().Get("lastName"); f != "" {
		q.Where(user.LastName(f))
	}

	es, err := q.All(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error querying database") // todo - better error
		render.InternalServerError(w, r, nil)
		return
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"user:list"}}, es)
	if err != nil {
		h.logger.WithError(err).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("amount", len(es)).Info("user rendered")
	render.OK(w, r, d)
}

func (h UserHandler) Sessions(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}
	q := h.client.User.Query().Where(user.ID(id)).QuerySessions()

	// Pagination
	page, itemsPerPage, err := h.paginationInfo(w, r)
	if err != nil {
		return
	}

	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	// Use the query parameters to filter the query. todo - nested filter?
	if f := r.URL.Query().Get("idleTimeExpiredAt"); f != "" {
		// todo
	}

	if f := r.URL.Query().Get("lifeTimeExpiredAt"); f != "" {
		// todo
	}

	es, err := q.All(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error querying database") // todo - better error
		render.InternalServerError(w, r, nil)
		return
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"session:list"}}, es)
	if err != nil {
		h.logger.WithError(err).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("amount", len(es)).Info("session rendered")
	render.OK(w, r, d)

}

func (h UserHandler) Accounts(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}
	q := h.client.User.Query().Where(user.ID(id)).QueryAccounts()

	// Pagination
	page, itemsPerPage, err := h.paginationInfo(w, r)
	if err != nil {
		return
	}

	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	// Use the query parameters to filter the query. todo - nested filter?
	if f := r.URL.Query().Get("title"); f != "" {
		q.Where(account.Title(f))
	}

	es, err := q.All(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error querying database") // todo - better error
		render.InternalServerError(w, r, nil)
		return
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"account:list"}}, es)
	if err != nil {
		h.logger.WithError(err).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("amount", len(es)).Info("account rendered")
	render.OK(w, r, d)

}

func (h UserHandler) Transactions(w http.ResponseWriter, r *http.Request) {
	id, err := h.urlParamInt(w, r, "id")
	if err != nil {
		return
	}
	q := h.client.User.Query().Where(user.ID(id)).QueryTransactions()

	// Eager load edges.
	q.WithAccount().WithTags(func(q *ent.TagQuery) {
		q.Order(ent.Asc("title"))
	})

	// Pagination
	page, itemsPerPage, err := h.paginationInfo(w, r)
	if err != nil {
		return
	}

	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	// Use the query parameters to filter the query. todo - nested filter?
	if f := r.URL.Query().Get("date"); f != "" {
		// todo
	}

	if f := r.URL.Query().Get("amount"); f != "" {
		i, err := strconv.Atoi(f)
		if err != nil {
			h.logger.WithError(err).WithField("amount", f).Debug("could not parse query parameter")
			render.BadRequest(w, r, "'amount' must be an integer")
			return
		}
		q.Where(transaction.Amount(i))
	}

	if f := r.URL.Query().Get("title"); f != "" {
		q.Where(transaction.Title(f))
	}

	es, err := q.All(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error querying database") // todo - better error
		render.InternalServerError(w, r, nil)
		return
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"transaction:list", "user:list", "tag:list"}}, es)
	if err != nil {
		h.logger.WithError(err).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("amount", len(es)).Info("transaction rendered")
	render.OK(w, r, d)

}

func (h handler) urlParamInt(w http.ResponseWriter, r *http.Request, param string) (id int, err error) {
	p := chi.URLParam(r, param)
	if p == "" {
		h.logger.WithField("param", param).Info("empty url param")
		render.BadRequest(w, r, param+" cannot be ''")
		return
	}

	id, err = strconv.Atoi(p)
	if err != nil {
		h.logger.WithField(param, p).Info("error parsing url parameter")
		render.BadRequest(w, r, param+" must be a positive integer greater zero")
		return
	}

	return
}

func (h handler) urlParamTime(w http.ResponseWriter, r *http.Request, param string) (date time.Time, err error) {
	p := chi.URLParam(r, param)
	if p == "" {
		h.logger.WithField("param", param).Info("empty url param")
		render.BadRequest(w, r, param+" cannot be ''")
		return
	}

	date, err = time.Parse("2006-01-02", p)
	if err != nil {
		h.logger.WithField(param, p).Info("error parsing url parameter")
		render.BadRequest(w, r, param+" must be a valid date in yyyy-mm-dd format")
		return
	}

	return
}

func (h handler) paginationInfo(w http.ResponseWriter, r *http.Request) (page int, itemsPerPage int, err error) {
	page = 1
	itemsPerPage = 30

	if d := r.URL.Query().Get("itemsPerPage"); d != "" {
		itemsPerPage, err = strconv.Atoi(d)
		if err != nil {
			h.logger.WithField("itemsPerPage", d).Info("error parsing query parameter 'itemsPerPage'")
			render.BadRequest(w, r, "itemsPerPage must be a positive integer greater zero")
			return
		}
	}

	if d := r.URL.Query().Get("page"); d != "" {
		page, err = strconv.Atoi(d)
		if err != nil {
			h.logger.WithField("page", d).Info("error parsing query parameter 'page'")
			render.BadRequest(w, r, "page must be a positive integer greater zero")
			return
		}
	}

	return
}
